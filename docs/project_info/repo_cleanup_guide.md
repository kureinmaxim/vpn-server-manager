# Руководство: Полная очистка истории Git-репозитория от конфиденциальных данных

Это руководство описывает процесс полного удаления конфиденциальных файлов из истории Git-репозитория, включая перезапись коммитов и обновление удаленного репозитория на GitHub.

## ⚠️ Предупреждение

**Эта операция является деструктивной и перезаписывает историю репозитория.** Все хэши коммитов изменятся. Перед началом убедитесь, что все участники проекта синхронизировали свои изменения, и предупредите их о предстоящей перезаписи истории.

## 1. Зачем это нужно?

Основная причина — **безопасность**. В Git-репозиторий никогда не должны попадать конфиденциальные данные, такие как:
- Ключи шифрования
- Файлы с паролями или токенами (`servers.json.enc`)
- Личные данные пользователей
- Загруженные файлы, которые не должны быть публичными (`uploads/`)

Если такие файлы случайно попали в историю коммитов, простое их удаление и новый коммит не решат проблему. Они останутся в истории, и любой сможет их восстановить. Требуется полная очистка истории.

## 2. План действий

1.  **Удаление релиза и тега** с GitHub.
2.  **Обновление `.gitignore`**, чтобы предотвратить повторное добавление файлов.
3.  **Установка `git-filter-repo`** — мощного инструмента для очистки истории.
4.  **Перезапись истории** с помощью `git-filter-repo` для удаления файлов.
5.  **Принудительная отправка (`force push`)** очищенной истории на GitHub.
6.  **Пересоздание релиза**.

## 3. Пошаговая инструкция с объяснением команд

### Шаг 1: Удаление релиза и тега с GitHub

Сначала мы удаляем публичный релиз и связанный с ним тег, чтобы подготовиться к перезаписи истории.

```bash
# 1. Получаем версию из config.json и формируем имя тега
VERSION=$(jq -r .app_info.version config.json)
TAG="v$VERSION"

# 2. Удаляем релиз с GitHub
# gh release delete <tag> --yes
# Команда удаляет релиз, связанный с указанным тегом.
# Флаг --yes подтверждает действие без интерактивного запроса.
gh release delete "$TAG" --yes | cat

# 3. Удаляем тег из удаленного репозитория
# git push origin :refs/tags/<tag>
# Эта специфическая команда удаляет тег на удаленном сервере (origin).
git push origin :refs/tags/"$TAG" | cat

# 4. Удаляем тег локально (на всякий случай)
git tag -d "$TAG" 2>/dev/null || true
```

### Шаг 2: Обновление `.gitignore`

Добавляем правила в `.gitignore`, чтобы конфиденциальные файлы больше никогда не попали в репозиторий.

```gitignore
# Конфиденциальные данные пользователя
data/*.enc
pin_block_state.json
uploads/
```

### Шаг 3: Установка `git-filter-repo`

Для очистки истории мы используем `git-filter-repo`. Это современный и безопасный инструмент.

```bash
# Установка с помощью pipx (изолированное окружение)
brew install pipx
pipx install git-filter-repo
```

### Шаг 4: Очистка истории Git

Эта команда проходит по всей истории коммитов и удаляет из нее файлы, соответствующие шаблону.

```bash
# git-filter-repo --path-glob 'data/*.enc' --invert-paths --force
# --path-glob 'data/*.enc': Указывает шаблон файлов для удаления.
# --invert-paths: Инвертирует выбор, то есть удаляет только то, что соответствует шаблону.
# --force: Требуется, так как мы работаем не со свежим клоном репозитория.
git-filter-repo --path-glob 'data/*.enc' --invert-paths --force
```
После выполнения этой команды история вашего локального репозитория будет перезаписана.

### Шаг 5: Принудительная отправка на GitHub

Так как мы изменили историю, обычный `git push` будет отклонен. Нам нужно принудительно перезаписать историю на удаленном сервере.

```bash
# 1. Восстанавливаем связь с удаленным репозиторием (git-filter-repo ее удаляет)
git remote add origin git@github.com:<user>/<repo>.git

# 2. Принудительно отправляем изменения
# git push --force --set-upstream origin main
# --force: Ключевой флаг. Говорит серверу: "Прими мою версию истории, даже если она отличается от твоей".
# --set-upstream origin main: Устанавливает связь между локальной и удаленной веткой `main`.
git push --force --set-upstream origin main | cat
```
**Важно:** Перед этим шагом вам может потребоваться временно отключить защиту ветки `main` в настройках репозитория на GitHub, если она запрещает `force push`.

### Шаг 6: Пересоздание релиза

Теперь, когда история чиста, можно заново создать релиз и прикрепить к нему артефакты.

```bash
# Команды те же, что и при обычном создании релиза
VERSION=$(jq -r .app_info.version config.json)
TAG="v$VERSION"
NOTES=$(cat CHANGELOG.md | ...) # Формируем описание

# Создаем релиз
gh release create "$TAG" --title "..." --notes "$NOTES" | cat

# Загружаем артефакт
gh release upload "$TAG" "path/to/asset.dmg" --clobber | cat
```

После выполнения всех шагов ваш репозиторий на GitHub будет содержать только "чистую" историю без конфиденциальных файлов. Не забудьте включить защиту ветки обратно!
